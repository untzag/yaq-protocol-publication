\documentclass[aip, amsmath, amssymb, reprint,]{revtex4-2}

\usepackage{graphicx}
\usepackage{dcolumn}
\usepackage{bm}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{mathptmx}
\usepackage{etoolbox}
\usepackage{hyperref}
\usepackage{url}

\newcommand\yaq{\texttt{yaq}}

\makeatletter
\def\@email#1#2{%
 \endgroup
 \patchcmd{\titleblock@produce}
  {\frontmatter@RRAPformat}
  {\frontmatter@RRAPformat{\produce@RRAP{*#1\href{mailto:#2}{#2}}}\frontmatter@RRAPformat}
  {}{}
}%
\makeatother
\begin{document}

\preprint{AIP/123-QED}

\title{The yaq Project: \\ Standardized Software Enabling Flexible Instrumentation}
\author{Kyle F. Sunden}
\author{Daniel D. Kohler}
\author{Kent A. Meyer}
\author{Peter L. Cruz Parrilla}
\author{John C. Wright}
\author{Blaise J. Thompson*}
\affiliation{
  University of Wisconsin--Madison;
  Madison, Wisconsin, 53706;
  USA
}
\email{blaise.thompson@wisc.edu}

\date{\today}

\begin{abstract}

Modern instrumentation development often involves incorporation of many dissimilar hardware peripherals into a single unified instrument.
Increasing availability of modular hardware has brought greater instrument complexity to small research groups.
This complexity stretches the capability of traditional, monolithic orchestration software.
In many cases, a lack of software flexibility leads creative researchers to feel frustrated, unable to perform experiments they envision.
Herein we describe \yaq{}, a software project defining a new standardized way of communicating with diverse hardware peripherals.
\yaq{} encourages a highly modular approach to experimental software development which is well suited to address the experimental flexibility needs of complex instruments.
\yaq{} is designed to overcome hardware communication barriers that challenge typical experimental software.
A large number of hardware peripherals are already supported, with tooling available to expand support.
The \yaq{} standard enables collaboration among multiple research groups, increasing code quality while lowering development effort.

\end{abstract}

\maketitle

\section{Introduction}

Instrumentation development is a key part of the scientific enterprise.
Novel instruments are typically constructed of many individual components that are both purchased and home-built.
Orchestration software must communicate with each hardware component in the course of a scientific experiment.
Orchestration can involve utilization of many interfaces: NI DAQmx\cite{nidaqmx}, SCPI\cite{scpi}, ModBus\cite{modbus}, PICam\cite{picam}, Thorlabs APT\cite{thorlabs_apt}, among many others.
The challenge of integrating all of these interfaces is a frustrating piece of the modern instrument development process.
Weeks can be spent just integrating one new component into an existing project.
In small academic labs, these software interfaces are typically created by student researchers without software development experience.
Student researchers rarely focus on software reusability, and a lack of maintenance and documentation can make such software more difficult to use as time goes on.
Scientists may struggle to rapidly innovate on their experimental design when each hardware addition requires major software development.

Some large user-facilities have addressed interface complexity via the adoption of unified standards, such as EPICS \cite{DalesioLR1991a} or TANGO \cite{AGotz1999TANGOA}.
The unified standards define a network interface for any hardware component.
Orchestration software can target these unified standards for reading and writing hardware state.
Small background services are written to translate the myriad component interfaces into the standard EPICS IOCs and TANGO Devices.
These programs are performant, open source, and have huge libraries of existing hardware interface support, but require expert management to set up and provide descriptions via a separate server program.
In our experience EPICS and TANGO do not scale well to single-investigator lab environments.

As smaller research labs have grown in experimental complexity, many individual labs have created domain-specific orchestration software.
In the last few years, several open source projects by-and-for small-scale experimentalists have grown in popularity\cite{WeberSebastien2021a,Bogdanowicz2022,trspectrometer,Koerner_2019,Campagnola_2014,pymeasure,Giesbrecht_2022,pylablib}.
While this growth is encouraging, many of these are limited by their focus on particular types of hardware or particular experimental domains.
More work needs to be done to catalog, compare, and contrast the large number of open-source projects that now exist.
Most small custom research instrumentation continues to rely on monolithic software which has hard-coded interface support for each particular connected device.
These monolithic applications tend to be inflexible and difficult to develop.

We have created a new network-based communication standard for scientific instrumentation, \yaq{} (Yet Another acQuisition)\footnote{see Supplementary Material for a full description of the name ``\yaq{}''}.
This standard borrows the most important ideas from established projects used by large user facilities while retaining the simplicity appropriate for small research labs.
We have built this standard to be self-describing, portable, and reusable wherever possible.
Via the \yaq{} interface, we provide easy-to-use hardware support for scientists to use with their choice of experiment orchestration software.

Here, we discuss the design of the \yaq{} standard in the context of challenges facing instrument designers.
First, we discuss how particularly challenging hardware interfaces can become seemingly insurmountable barriers to software control.
Next, we discuss how inflexible orchestration software can limit experimental creativity.
Then, we focus on challenges that arise when enhancing or modifying existing instruments with new hardware.
Finally, we discuss the heavy software maintenance burden that many instrument designers face.
In each case, we will highlight how the \yaq{} project is designed to alleviate that challenge.
Several case studies provide a view into the flexible ways that \yaq{} can be applied to perform different scientific experiments.
This paper provides an overview of the concepts and motivations behind \yaq{}.
Refer to the \yaq{} website for a formal specification of the \yaq{} standard.\footnote{The \yaq{} protocol is fully specified by the set of accepted \yaq{} Enhancement Proposals at https://yeps.yaq.fyi/}

\section{Hardware Interface Challenges}

In this section we describe the architecture of the \yaq{} framework in light of three major barriers that we have encountered in scientific instrumentation development.
First barrier: Multiple interfaces are used to communicate with each component of the system.
A fully automated system must be able to use all of these interfaces, a daunting task for scientists who do not specialize in software development.
Second barrier: Certain specialty hardware have inconvenient interface requirements.
A camera will only work with an obsolete interface card and drivers for Windows XP.
A data acquisition manufacturer provides an Application Programmer Interface (API) that only works in Python 3.7.
A graduate student wishes to drive several stepper motors using a Raspberry Pi.
Third barrier: Some hardware interfaces are blocking.
A graphical user interface stalls while waiting for a camera to collect data.
Custom orchestration software needs to be closed before the manufacturers configuration software can be used.
A graduate student finds themself needing to master advanced concepts in concurrency in order to orchestrate many motors performantly.

\begin{figure}
    \includegraphics[width=\columnwidth]{figures/network}
    \caption{\label{fig:network} Simplified network diagram for a hypothetical instrument. Three computers are connected via orange Ethernet cables and a network switch (middle right). Some of the computers are also connected to hardware peripherals via one of six interfaces (colored lines). For each interface, the computer runs a \yaq{} daemon (small colored squares). The top and bottom computers are also running \yaq{} client applications.}
\end{figure}

Figure \ref{fig:network} diagrams the \yaq{} architecture.
Here, we show three different computers connected via an Ethernet network.
The top and bottom computer are connected to monitors for interactive use while the middle computer is only accessible via the networks.
This diagram might represent a complex scientific instrument involving several operator terminals as well as embedded computers.
At the top, a single computer is connected to four hardware peripherals through RS232, TTL, USB, and PCI as indicated by the colored lines.
That same computer is running four separate programs, one for each peripheral.
These small, targeted, programs are managed by the operating system and run in the background.
It is conventional to call such programs ``daemons''\cite{Raymond_1996}.
The middle computer is connected to two additional peripherals, and runs daemons for each.
Besides communicating with the hardware peripheral, each daemon can communicate with other programs, ``clients'',  through the network.
The four client programs shown in Figure \ref{fig:network} can each communicate with all six hardware peripherals shown.
As an example, a client running on the bottom computer could communicate with the RS232 peripheral shown in green via the following path: client $\leftrightarrow$ network switch $\leftrightarrow$ top computer $\leftrightarrow$ daemon $\leftrightarrow$ hardware peripheral.
This powerful architecture can be used on a single computer or used across many networked computers, including fully remote operator interfaces.
This client-server architecture offers similar network capabilities to EPICS and TANGO.
As we will show, usage of standards and the creation of tooling makes this architecture accessible to instrument builders outside of large facilities.

In \yaq{}, communication between daemons and clients is performed over TCP/IP using Apache Avro RPC \cite{AvroSpecification}.
Avro provides an agreed upon standard for efficient serialization of data and method calls from a remote (client) process.
Practically, the \yaq{} interface looks like a collection of methods or functions, which Avro calls ``messages''.
Each message has defined input parameters and output return types.
A sensor might implement a message called ``\texttt{get\_measured}'' which takes no parameters and returns a dictionary mapping channel names to numeric or array data.
A motor would implement a pair of messages for setting and reading back the motor position: ``\texttt{set\_position(float position)} $\rightarrow$ \texttt{null}'' and ``\texttt{get\_position()} $\rightarrow$ \texttt{float}''.
Messages make up the lowest level functionality of the \yaq{} interface.
Each daemon supports a collection of messages for its unique functionality, called the ``protocol''.
When a client first connects to a daemon over TCP/IP, the daemon provides a complete description of its own protocol.
We therefore refer to the daemons as ``self-describing''.

Each individual communication between client and daemon involves one message being requested by the client and the response returned from the daemon.
If multiple messages are sent simultaneously, the daemon processes one message at a time.
The protocol is preemptive: in the case of a conflict, the daemon will obey the last message to arrive.
By being completely open to messages from multiple clients, \yaq{} makes it possible to accidentally supersede a message.
This has not become a problem for our usage where instruments are controlled by single scientists who can clearly see all of the clients interacting with their system.
Typically there is just one client sending `set\_position` and many clients polling `get\_position` to record data or display real-time information.
Users may choose to implement access control systems, but we do not foresee building access control into the \yaq{} protocol.
This is similar to how access control works in practice at some large facilities.

\yaq{} introduces a concept called ``traits'' which are collections of related messages that are shared among multiple protocols.
Motors implement the ``\texttt{has-position}'' trait, which defines ``\texttt{set\_position}'', ``\texttt{get\_position}'', and ``\texttt{get\_units}''.
Sensors would implement the ``\texttt{is-sensor}'' trait which defines ``\texttt{get\_measured}'', ``\texttt{get\_channel\_names}'', and ``\texttt{get\_channel\_units}''.
Protocols which implement a trait must support all of the messages from the trait.
Traits are compositional: a given protocol may implement several traits at once.
For example, a protocol representing a monochromator with several gratings might implement both ``\texttt{has-position}`` and ``\texttt{has-turret}``, where the latter defines special messages for choosing which grating is used.
Importantly, specific protocols can also implement arbitrary additional messages that are not defined by any trait.

We have carefully defined \yaq{} traits to maximize interoperability while not excluding hardware with unusual features.
New traits can be discussed by the community through the yaq enhancement proposal system.
It's crucial that multiple hardware interface examples be considered when defining traits.
Configuration that is unique to a single interface is best handled through protocol-specific messages.
For example, our protocol for interfacing with a specific data acquisition card provides a message for setting the segment count.
Unique messages are avaliable through script-based and graphical clients, but usage of such messages in scripts naturally limits portability.

We now describe how the \yaq{} architecture addresses the three hardware interface barriers described at the beginning of this section.
The first hardware interface barrier: Multiple incompatible interfaces are used to communicate with each component of the system. % consider making this sentence (and the next paragraph starts) subsection headings
\yaq{} provides a unified TCP/IP interface to all hardware peripherals based on the well-described Avro RPC protocol.
The trait system was introduced in pursuit of our primary goal of easing the client development process.
Clients can trust that protocols that implement a given trait will behave in similar ways.
The standardized \yaq{} interface presents the same set of interactions for client-side scientific code, simplifying the experience of using hardware.

The second hardware interface barrier: Certain specialty hardware have inconvenient interface requirements.
Since \yaq{} enables multiple machines, any hardware requirements can be addressed by putting a machine for that specific hardware on the network.
The Raspberry Pi which drives several stepper motors can be placed onto a private network to communicate with the primary instrument computer using \yaq{}.
Because each \yaq{} daemon is running in its own process, the software environment can be tailored to its needs.
A client running up-to-date Python 3.11 communicates seamlessly with a daemon running Python 3.7.

The third hardware interface barrier: Some hardware interfaces are blocking or slow.
Experimental orchestration often means doing several things at once, \textit{e.g.} simultaneously moving several motors.
To accomplish this task performantly, monolithic orchestration software often necessitates separate threads for each component hardware interface, a fragile pattern in which small mistakes become both critical and elusive errors.
When writing orchestration software using \yaq{}, slow hardware interfaces are replaced by fast Avro-RPC.
In our experience, the \yaq{} interface is responsive enough to give good performace when orchestrating tens of motors using a singly-threaded client.
There is a limit where using TCP becomes a bottleneck for large resonses, such as those from cameras or other high throughput sensors.
In our experience, this limit is approximately 1 megapixel.
For larger sensors, a pure \yaq{} approach may not be appropriate.
There is a longer discussion of timing and order-of-operations control details using \yaq{} in the Supplementary Material.

\section{Experimental Flexibility}

Existing experimental orchestration software is often highly inflexible.
An experimentalist will spend many hours in lab manually repeating acquisitions because it is too challenging to add repetition functionality to their software.
A laser lab needs to spend weeks on software development when introducing a single new step into their experimental procedure.
Researchers are disappointed to realize that they are forced to start from scratch when developing software for a similar instrument built with trivially different hardware.

Unique experiments will always need custom orchestration and user experience.
We believe that novel instrumentation development naturally and necessarily includes the creation of targeted software.
Developing experimental software is an iterative process tied to the scientific goals of the instrument.
Often experimentalists must apply their specialty scientific knowledge to develop this software.\cite{SegalJudith2005a} % citation does not compile

In our view, software inflexibility is a natural consequence of the typical software development practices used by custom instrument builders.
Instrumental software is often built as one monolithic program that does everything from providing a graphical interface, through hardware interfacing, and writing data files.
Such software is typically impossible to debug without access to real hardware, often requiring all of the hardware to be available to simply start the program.
As such, instrumentation software development time is in conflict with valuable data acquisition time.
The hardware interfaces that these programs implement are typically made quickly and without regard to standardization with similar hardware.
The orchestration routines are intimately tied to the particular hardware configuration of one instrument.

\yaq{} is architected to encourage better software development practices when creating such programs.
In a \yaq{} context, orchestration code and graphical control interfaces are implemented as clients.
These clients are automatically simpler because they only need to implement the \yaq{} standard and do not need to include the vast array of hardware-specific communication interfaces.
Beyond this, clients can use traits to interact with similar hardware identically.
A client written to perform a two dimensional fluorescence experiment using two Acton monochromators will also work with Horiba monochromators without any modification.

\begin{figure}
  \includegraphics[width=\columnwidth]{figures/client_spectrum}
  \caption{\label{fig:foundation} Representations of three very different \yaq{} client experiences. Top: light-weight scripting. Middle: graphical user interface. Bottom: integration with Bluesky for data collection. In all three cases the same daemons are addressed.}
\end{figure}

Figure \ref{fig:foundation} shows that \yaq{} supports a diverse array of client types.
At the top, we represent the most lightweight interface to \yaq{}, Python scripting.
\texttt{yaqc}\footnote{\texttt{yaqc} available on PyPI at https://pypi.org/project/yaqc/} is a Python client which is excellent for using in scripts or any other Python program.
The code shown creates three client objects which could be used directly through an interactive Python prompt or in a reusable script.
Each client object provides Python methods for each Avro message specified by the associated protocol.

In the middle, the same three hardware peripherals are represented in an interactive, graphical form.
\texttt{yaqc-qtpy}\footnote{\texttt{yaqc-qtpy} available on PyPI at https://pypi.org/project/yaqc-qtpy/} is a graphical application which builds interactive controls based on traits for any conceivable \yaq{} protocol.
The self-describing \yaq{} interface is used to provide graphical elements for the most commonly used messages.
\texttt{yaqc-qtpy} is an invaluable tool which provides a ``free'' graphical user interface (GUI) to any daemon.

At the bottom, we graphically represent the integration between \yaq{} and the Bluesky project\cite{AllanDanielB2019a}.
Bluesky provides a powerful orchestration layer for conducting and recording data for a wide variety of experimental procedures.
Bluesky has no built-in hardware interface support, instead relying on packages to create hardware-interfaces that are compatible with their Hardware Protocol defintions.
\texttt{yaqc-bluesky}\footnote{\texttt{yaqc-bluesky} available on PyPI at https://pypi.org/project/yaqc-bluesky/} is a specialized client which adapts any \yaq{} protocol into Bluesky.
Similar translation layers could be built for a variety of orchestration software such as PyMoDAQ\cite{WeberSebastien2021a}, PyMeasure\cite{pymeasure}, or TRSpectrometer\cite{trspectrometer}.

All three types of clients represented in Figure \ref{fig:foundation} have been shown addressing the same three hardware peripherals.
All types of clients can be used simultaneously to interact with the same instrument in different modes.
Client sophistication can be introduced naturally, as novel experiments are tested and refined.
Different clients can specialize for different requirements of a custom instrument.
For example, \texttt{yaqc-qtpy} can provide a quick interface for setting and viewing hardware positions while Bluesky can focus on experimental data acquisition.

The Landis Group at UW-Madison is currently working on a new type of flow reactor: the Wisconsin Quench Kinetics Reactor (WiQK).
This reactor incorporates several computer-controlled valves and syringe pumps as well as various sensors.
The set of hardware peripherals is rapidly changing as researchers continue to test and refine their design.
Only a few researchers are actively using the reactor during this prototyping stage.
These researchers are experimentalists who have limited background in software development.
The Landis Group has written basic Python scripts to orchestrate hardware for their reactor.
These lightweight scripts can be extensively refactored by the experimentalists as the hardware and orchestration strategy changes dramatically during WiQK development.
This approach ensures that the Landis Group is not slowed down by complex, inflexible orchestration software.
Once the reactor is complete, more sophisticated graphical clients will be created to accommodate end users who were not involved as the reactor was built.

The Wright Group at UW-Madison needs to orchestrate a large variety of hardware in multidimensional scans for their complex spectroscopy experiments \cite{MukamelShaul2000a, WrightJohnCurtis2011a}.
This need for exquisite hardware control has resulted in several prior attempts at ``home-built'' orchestration software \cite{CarlsonRogerJohn1988a, MeyerKentAlbert2004b, KainSchuyler2017a, ThompsonBlaiseJonathan2018a, SundenKyle2022}.
Now, using \yaq{}, the Wright Group has been able to move to Bluesky rather than inventing their own sophisticated control software ``from scratch''.
The Wright Group uses simulated hardware to enable client development away from the active laboratory computers.
Hardware simulation allows Wright Group researchers to create polished client interfaces without interrupting  ongoing experiments.
Clients developed by the Wright Group have proved flexible enough to be used on four laser systems, each with different complements of hardware.
Moving forward, the Wright Group will spend less energy developing control software and more energy developing creative spectroscopy experiments.

\section{Incorporating New Hardware}

In a \yaq{} context, new hardware can be incorporated into an instrument through the addition of a new daemon.
The \yaq{} architecture simplifies hardware interface development in several ways.
First, because daemons are separate and portable programs, the development effort can be spread across the community of \yaq{} users.
Often, researchers can download an existing daemon rather than writing a new one.
Second, \yaq{} daemon development can be performed separately from the particulars of any individual client.
Often, this separation allows initial hardware enablement work to be done on a researchers personal machine before the new hardware peripheral is installed in the instrument.
Separability, portability, and distributed development are advantages common to many open-source hardware interface projects.
Third, when developing trait-compliant protocols, it becomes easy to design and fully test your hardware interface.
Traits are unambiguous and well-described, making an obvious target for development.
Tooling exists to verify full trait compliance, for example you can use \texttt{yaqc-qtpy} to provide a graphical program to interact with your hardware immediately.
Finally, as discussed in Section II, \yaq{} provides options to design using remote hardware or unusual interfaces when necessary.

We have created several tools to aide in daemon development.
First, a Python library, \texttt{yaqd-core}\footnote{\texttt{yaqd-core-python} available on PyPI at https://pypi.org/project/yaqd-core}, which implements shared functionality.
Second, \texttt{yaq-traits}\footnote{\texttt{yaq-traits} available on PyPI at https://pypi.org/project/yaq-traits} is a command line application which allows the description of messages provided by a \yaq{} protocol to be written in a human-readable fashion and translated into a more fully described machine readable format.
The format it generates is an important part of how \yaq{} protocols are self-describing.
This shields developers from the details of Apache Avro, which can be somewhat esoteric.

\begin{figure}
\includegraphics[width=\columnwidth]{figures/lines_histogram},
	\caption{  \label{fig:histogram} Histogram of the number of lines for each implemented daemon.
	Some daemons are implemented in ways that share code, resulting in apparent line counts less than 10.
	For example, the Thorlabs APT\cite{thorlabs_apt} motor implementation supports at least eight different daemons with each specifying only a handful of constants.
	These are extreme examples which are not representative of most hardware interfaces, so we omit them here.
	}
\end{figure}

Figure \ref{fig:histogram} shows the distribution of unique lines of Python code written to implement each of the daemons in our current ecosystem.
While lines of code is an imperfect metric, we use it here to represent the amount of work required to create a daemon for a new hardware peripheral.
Most interfaces, such as Brooks MFC\footnote{\texttt{yaqd-brooks-mfc-gf} source code available on GitHub at \texttt{https://github.com/yaq-project/yaqd-brooks/}}, have been implemented in fewer than 100 lines of Python code.
Even the most complicated daemons are implemented in about 300 lines.
Implementing \yaq{} daemons using Python is enabled through our own tooling mentioned above and the large and growing ecosystem of hardware interface libraries that Python now provides\cite{pyserial, pyusb, pyvisa, pymodbus}.
In our experience, the process of creating a new daemon involves about a day of work after mastering communication with the hardware.
There are currently 72 daemons in the yaq project supporting at least 66 types of hardware, noting that some daemons support the same hardware and others are software only.
Because \yaq{} is standards based, anyone can design and publish new daemons extending our hardware support.
A living list of all daemons and supported hardware can be found on the \yaq{} website.\footnote{See https://yaq.fyi/daemons/ and https://yaq.fyi/hardware/ for living lists of all \yaq{} daemons and supported hardware, respectively.}

The Stahl Group at UW-Madison created a custom reactor which monitors gasses being produced or consumed in the reaction head-space.  \cite{SalazarChaseA2021a}
This reactor incorporates a collection of sensitive pressure transducers and a single heating process value under computer control.
\yaq{} daemons are used to interface with each sensor and the heater controller.
Recently, experimentalists have been attempting reactions involving smaller, slower, pressure changes.
A fundamental flaw in the initial analog to digital converter board was revealed by these attempts.
As a result, a new digitizer has been purchased.
This new digitizer will be incorporated into the existing reactor without modifying the existing graphical user interface and data recording program, minimizing downtime.

\section{Technical Debt}

Years after the original researchers leave, large monolithic acquisition programs become unknowable, undocumented, and unmaintained.
A graduate student discovers a hard-coded conversion factor that is incorrect years after implementation.
Scientists resort to sourcing an exact replacement for an old, broken oscilloscope due to their software's reliance on that particular interface---newer, cheaper oscilloscopes are readily available.
A graduate student is forced to meticulously reverse engineer the LabVIEW codebase that they inherited in order to understand the details of their experiment.
Software developers refer to the extra effort required to modify or fix large unmaintained codebases as ``technical debt''.\cite{Allman_2012}
Technical debt grows especially fast in academic environments where graduate students are involved in projects for a limited time.

The \yaq{} approach favors many small single-purpose applications above large monolithic ones.
For daemons, the purpose of each application is obvious and unambiguous.
There is a strict, well defined interface which explicitly limits the kinds of interactions that are provided to the hardware, thus limiting opportunity for unintended consequences.
The lack of hardware interface code makes \yaq{} clients much simpler and easier to describe and maintain.
Tools like \texttt{yaqd-fakes}\footnote{\texttt{yaqd-fakes} available on PyPI at https://pypi.org/project/yaqd-fakes/} allow clients to be tested and improved outside of their instrument, including the possibility of fully automated testing.
Simple, script-based clients written using the expressiveness of Python can be read and understood in hours rather than weeks.
Integrations with communities like Bluesky offer powerful features which are actively maintained across many institutions.

In \yaq{}, each component of an instrument can be developed and distributed separately.
For example, two different instruments might happen to use the same temperature sensor.
Because the temperature sensor daemon is its own independent program, both instruments can benefit from the same daemon.
The growing ``ecosystem'' of \yaq{} daemons make future instruments easier and easier to develop.
Growing this ecosystem is a collaborative effort where many \yaq{} users create portable daemons that they need and share them with the community where they will be used and improved.
\yaq{} components can be incorporated seamlessly into existing software projects, including languages other than Python.
For example, an existing LabVIEW project may provide additional hardware support via \yaq{}.
In this way, a more modular instrument can be built gradually without needing to overhaul all of the software simultaneously.

Software built by scientists often has incomplete and inadequate documentation. \cite{SegalJudith2007a}
\yaq{} attempts to automate daemon documentation as much as possible.
Our website, https://yaq.fyi, automatically builds generated reference pages for all known protocols.
These pages are automatically updated when new versions are published.
Our website also contains written and video tutorials on \yaq{} usage and development.

We have designed \yaq{} to be easier to deploy and maintain when compared to EPICS and TANGO.
\yaq{} daemons are Python packages that can be installed on any platform using pip or conda.
There is no need for centralized management servers or databases when using \yaq{}.
The Avro RPC standard unambiguously describes the message signatures for any protocol, so users are always aware of the capabilities their hardware supports.
Traits enable interchangability where possible.
\yaq{} can easily be used alongside other experiment control software.
We provide tooling (\texttt{yaqd-control}) which makes it easy to configure, list, and manage daemons as background services on Windows, MacOS, or Linux (See SI for more details).

\yaq{} is open source software.
Anyone can view, install, edit, and suggest changes to our growing collection of daemons and clients.
Furthermore, anyone can create their own totally-custom client or daemon software separately by following the specified \yaq{} standard.
Thirteen individuals have contributed code to the development of \yaq{}.
Open-source development can be a powerful approach for research communities looking to share software-development and maintenance burdens. \cite{CohenJeremy2021a}
It is our hope that a vibrant open-source community will form around \yaq{}.
While open-source development is not a panacea \cite{NowogrodzkiAnna2019a}, we hope that by maintaining a distributed development strategy with a strict focus on only hardware interfaces, the \yaq{} project might prove sustainable.

\section{Conclusion}

The \yaq{} project defines a new general-purpose standard for hardware control in the context of scientific instrumentation.
This standard has some of the powerful features of facility-scale standards while remaining simple enough for feasible implementation and maintenance in small research labs.
We have shown how this approach alleviates common problems through discussion and case studies.
Designing around self-describing protocols is a productive approach that has great promise in scientific software development.

\section*{Supplementary Material}

Full set of line-count data and script used to produce Figure \ref{fig:histogram}.
More detailed examples of orchestration using \yaq{}, including scripts and graphical user interfaces.
Detailed description of \texttt{yaqd-control}.
Discussion and quantitative analysis of the \yaq{} interface's performance with large arrays.

\begin{acknowledgments}

The authors would like to thank all \yaq{} users and contributors.
We would also like to acknowledge the developers of the broader open-source software community upon-which this project rests.

This work was supported by the National Science Foundation under grant CHE-1709060.

\end{acknowledgments}

\section*{Data Availability Statement}

The data that supports the findings of this study are available within the supplementary material.

\section*{References}
%aipnum4-2.bst 2019-01-14 (MD) hand-edited version of apsrev4-1.bst
%Control: key (0)
%Control: author (8) initials jnrlst
%Control: editor formatted (1) identically to author
%Control: production of article title (0) allowed
%Control: page (1) range
%Control: year (1) truncated
%Control: production of eprint (0) enabled
\begin{thebibliography}{45}%
\makeatletter
\providecommand \@ifxundefined [1]{%
 \@ifx{#1\undefined}
}%
\providecommand \@ifnum [1]{%
 \ifnum #1\expandafter \@firstoftwo
 \else \expandafter \@secondoftwo
 \fi
}%
\providecommand \@ifx [1]{%
 \ifx #1\expandafter \@firstoftwo
 \else \expandafter \@secondoftwo
 \fi
}%
\providecommand \natexlab [1]{#1}%
\providecommand \enquote  [1]{``#1''}%
\providecommand \bibnamefont  [1]{#1}%
\providecommand \bibfnamefont [1]{#1}%
\providecommand \citenamefont [1]{#1}%
\providecommand \href@noop [0]{\@secondoftwo}%
\providecommand \href [0]{\begingroup \@sanitize@url \@href}%
\providecommand \@href[1]{\@@startlink{#1}\@@href}%
\providecommand \@@href[1]{\endgroup#1\@@endlink}%
\providecommand \@sanitize@url [0]{\catcode `\\12\catcode `\$12\catcode
  `\&12\catcode `\#12\catcode `\^12\catcode `\_12\catcode `\%12\relax}%
\providecommand \@@startlink[1]{}%
\providecommand \@@endlink[0]{}%
\providecommand \url  [0]{\begingroup\@sanitize@url \@url }%
\providecommand \@url [1]{\endgroup\@href {#1}{\urlprefix }}%
\providecommand \urlprefix  [0]{URL }%
\providecommand \Eprint [0]{\href }%
\providecommand \doibase [0]{https://doi.org/}%
\providecommand \selectlanguage [0]{\@gobble}%
\providecommand \bibinfo  [0]{\@secondoftwo}%
\providecommand \bibfield  [0]{\@secondoftwo}%
\providecommand \translation [1]{[#1]}%
\providecommand \BibitemOpen [0]{}%
\providecommand \bibitemStop [0]{}%
\providecommand \bibitemNoStop [0]{.\EOS\space}%
\providecommand \EOS [0]{\spacefactor3000\relax}%
\providecommand \BibitemShut  [1]{\csname bibitem#1\endcsname}%
\let\auto@bib@innerbib\@empty
%</preamble>
\bibitem [{nid(2022)}]{nidaqmx}%
  \BibitemOpen
  \href@noop {} {\enquote {\bibinfo {title} {Getting started with
  {NI-DAQmx}},}\ }\bibinfo {howpublished}
  {\url{https://www.ni.com/en-us/support/documentation/supplemental/06/getting-started-with-ni-daqmx--main-page.html}}
  (\bibinfo {year} {2022}),\ \bibinfo {note} {accessed: 2022-10-02}\BibitemShut
  {NoStop}%
\bibitem [{scp(1999)}]{scpi}%
  \BibitemOpen
  \href@noop {} {\emph {\bibinfo {title} {Standard Commands for Programmable
  Instruments (SCPI)}}},\ \bibinfo {organization} {SCPI Consortium} (\bibinfo
  {year} {1999})\BibitemShut {NoStop}%
\bibitem [{mod(2012)}]{modbus}%
  \BibitemOpen
  \href@noop {} {\emph {\bibinfo {title} {MODBUS Application Protocol
  Specification}}},\ \bibinfo {organization} {Modbus} (\bibinfo {year}
  {2012})\BibitemShut {NoStop}%
\bibitem [{pic(2021)}]{picam}%
  \BibitemOpen
  \href@noop {} {\emph {\bibinfo {title} {PICam 5.x Programmer’s Manual}}},\
  \bibinfo {organization} {Teledyne Princeton Instruments} (\bibinfo {year}
  {2021})\BibitemShut {NoStop}%
\bibitem [{tho(2022)}]{thorlabs_apt}%
  \BibitemOpen
  \href@noop {} {\emph {\bibinfo {title} {Thorlabs Motion Controllers
  Host-Controller Communications Protocol}}},\ \bibinfo {organization}
  {Thorlabs} (\bibinfo {year} {2022})\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Dalesio}, \citenamefont {Kraimer},\ and\
  \citenamefont {Kozubal}(1991)}]{DalesioLR1991a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {L.~R.}\ \bibnamefont
  {Dalesio}}, \bibinfo {author} {\bibfnamefont {M.~R.}\ \bibnamefont
  {Kraimer}},\ and\ \bibinfo {author} {\bibfnamefont {A.~J.}\ \bibnamefont
  {Kozubal}},\ }\bibfield  {title} {\enquote {\bibinfo {title} {{EPICS}
  architecture},}\ }\href@noop {} {\bibfield  {journal} {\bibinfo  {journal}
  {ICALEPCS}\ }\textbf {\bibinfo {volume} {91}} (\bibinfo {year}
  {1991})}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Chaize}\ \emph {et~al.}(1999)\citenamefont {Chaize},
  \citenamefont {Götz}, \citenamefont {Meyer}, \citenamefont {Pérez},\ and\
  \citenamefont {Taurel}}]{AGotz1999TANGOA}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {J.-M.}\ \bibnamefont
  {Chaize}}, \bibinfo {author} {\bibfnamefont {A.}~\bibnamefont {Götz}},
  \bibinfo {author} {\bibfnamefont {J.}~\bibnamefont {Meyer}}, \bibinfo
  {author} {\bibfnamefont {M.}~\bibnamefont {Pérez}},\ and\ \bibinfo {author}
  {\bibfnamefont {E.}~\bibnamefont {Taurel}},\ }\bibfield  {title} {\enquote
  {\bibinfo {title} {{TANGO} - an object oriented control system based on
  {CORBA}},}\ }in\ \href@noop {} {\emph {\bibinfo {booktitle} {ICALEPCS}}}\
  (\bibinfo {year} {1999})\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Weber}(2021)}]{WeberSebastien2021a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {S.~J.}\ \bibnamefont
  {Weber}},\ }\bibfield  {title} {\enquote {\bibinfo {title} {{PyMoDAQ}: An
  open-source python-based software for modular data acquisition},}\ }\href
  {https://doi.org/10.1063/5.0032116} {\bibfield  {journal} {\bibinfo
  {journal} {Review of Scientific Instruments}\ }\textbf {\bibinfo {volume}
  {92}},\ \bibinfo {pages} {045104} (\bibinfo {year} {2021})}\BibitemShut
  {NoStop}%
\bibitem [{\citenamefont {Bogdanowicz}\ \emph {et~al.}(2022)\citenamefont
  {Bogdanowicz}, \citenamefont {Rogers}, \citenamefont {Weber}, \citenamefont
  {{Zakv}}, \citenamefont {Pelissier}, \citenamefont {Wheeler}, \citenamefont
  {{Cxz}}, \citenamefont {Marazzi}, \citenamefont {{Eedm}},\ and\ \citenamefont
  {Galinskiy}}]{Bogdanowicz2022}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {N.}~\bibnamefont
  {Bogdanowicz}}, \bibinfo {author} {\bibfnamefont {C.}~\bibnamefont {Rogers}},
  \bibinfo {author} {\bibfnamefont {S.}~\bibnamefont {Weber}}, \bibinfo
  {author} {\bibnamefont {{Zakv}}}, \bibinfo {author} {\bibfnamefont
  {S.}~\bibnamefont {Pelissier}}, \bibinfo {author} {\bibfnamefont
  {J.}~\bibnamefont {Wheeler}}, \bibinfo {author} {\bibnamefont {{Cxz}}},
  \bibinfo {author} {\bibfnamefont {F.}~\bibnamefont {Marazzi}}, \bibinfo
  {author} {\bibnamefont {{Eedm}}},\ and\ \bibinfo {author} {\bibfnamefont
  {I.}~\bibnamefont {Galinskiy}},\ }\href
  {https://doi.org/10.5281/ZENODO.2556398} {\enquote {\bibinfo {title}
  {Instrumental: A python-based library for controlling lab hardware},}\ }
  (\bibinfo {year} {2022})\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Tapping}(2021)}]{trspectrometer}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {P.}~\bibnamefont
  {Tapping}},\ }\href@noop {} {\enquote {\bibinfo {title} {{TRSpectrometer}
  documentation},}\ }\bibinfo {howpublished}
  {\url{https://trspectrometer.readthedocs.io/}} (\bibinfo {year} {2021}),\
  \bibinfo {note} {accessed: 2022-10-02}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Koerner}(2019)}]{Koerner_2019}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {L.}~\bibnamefont
  {Koerner}},\ }\bibfield  {title} {\enquote {\bibinfo {title} {Instrbuilder: A
  {Python} package for electrical instrument control},}\ }\href
  {https://doi.org/10.21105/joss.01172} {\bibfield  {journal} {\bibinfo
  {journal} {Journal of Open Source Software}\ }\textbf {\bibinfo {volume}
  {4}},\ \bibinfo {pages} {1172} (\bibinfo {year} {2019})}\BibitemShut
  {NoStop}%
\bibitem [{\citenamefont {Campagnola}, \citenamefont {Kratz},\ and\
  \citenamefont {Manis}(2014)}]{Campagnola_2014}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {L.}~\bibnamefont
  {Campagnola}}, \bibinfo {author} {\bibfnamefont {M.~B.}\ \bibnamefont
  {Kratz}},\ and\ \bibinfo {author} {\bibfnamefont {P.~B.}\ \bibnamefont
  {Manis}},\ }\bibfield  {title} {\enquote {\bibinfo {title} {Acq4: an
  open-source software platform for data acquisition and analysis in
  neurophysiology research},}\ }\href
  {https://doi.org/10.3389/fninf.2014.00003} {\bibfield  {journal} {\bibinfo
  {journal} {Frontiers in Neuroinformatics}\ }\textbf {\bibinfo {volume} {8}}
  (\bibinfo {year} {2014}),\ 10.3389/fninf.2014.00003}\BibitemShut {NoStop}%
\bibitem [{pym(2022)}]{pymeasure}%
  \BibitemOpen
  \href@noop {} {\enquote {\bibinfo {title} {{PyMeasure}},}\ }\bibinfo
  {howpublished} {\url{https://pymeasure.readthedocs.io/}} (\bibinfo {year}
  {2022}),\ \bibinfo {note} {accessed: 2022-10-02}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Giesbrecht}\ \emph {et~al.}(2022)\citenamefont
  {Giesbrecht}, \citenamefont {Amsellem}, \citenamefont {Bauer}, \citenamefont
  {Mak}, \citenamefont {Wynne}, \citenamefont {Qin},\ and\ \citenamefont
  {Persaud}}]{Giesbrecht_2022}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {G.}~\bibnamefont
  {Giesbrecht}}, \bibinfo {author} {\bibfnamefont {A.}~\bibnamefont
  {Amsellem}}, \bibinfo {author} {\bibfnamefont {T.}~\bibnamefont {Bauer}},
  \bibinfo {author} {\bibfnamefont {B.}~\bibnamefont {Mak}}, \bibinfo {author}
  {\bibfnamefont {B.}~\bibnamefont {Wynne}}, \bibinfo {author} {\bibfnamefont
  {Z.}~\bibnamefont {Qin}},\ and\ \bibinfo {author} {\bibfnamefont
  {A.}~\bibnamefont {Persaud}},\ }\bibfield  {title} {\enquote {\bibinfo
  {title} {Hardware-control: Instrument control and automation package},}\
  }\href {https://doi.org/10.21105/joss.02688} {\bibfield  {journal} {\bibinfo
  {journal} {Journal of Open Source Software}\ }\textbf {\bibinfo {volume}
  {7}},\ \bibinfo {pages} {2688} (\bibinfo {year} {2022})}\BibitemShut
  {NoStop}%
\bibitem [{\citenamefont {Shkarin}(2022)}]{pylablib}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {A.}~\bibnamefont
  {Shkarin}},\ }\href {https://doi.org/10.5281/zenodo.7324876} {\enquote
  {\bibinfo {title} {{pyLabLib}},}\ }\bibinfo {howpublished}
  {\url{https://doi.org/10.5281/zenodo.7324876}} (\bibinfo {year}
  {2022})\BibitemShut {NoStop}%
\bibitem [{Note1()}]{Note1}%
  \BibitemOpen
  \bibinfo {note} {See Supplementary Material for a full description of the
  name ``\protect \texttt {yaq}{}''}\BibitemShut {NoStop}%
\bibitem [{Note2()}]{Note2}%
  \BibitemOpen
  \bibinfo {note} {The \protect \texttt {yaq}{} protocol is fully specified by
  the set of accepted \protect \texttt {yaq}{} Enhancement Proposals at
  https://yeps.yaq.fyi/}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Raymond}(1996)}]{Raymond_1996}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {E.~S.}\ \bibnamefont
  {Raymond}},\ }\href@noop {} {\emph {\bibinfo {title} {The new hacker’s
  dictionary}}},\ \bibinfo {edition} {3rd}\ ed.\ (\bibinfo  {publisher} {MIT
  Press},\ \bibinfo {address} {Cambridge, Mass},\ \bibinfo {year}
  {1996})\BibitemShut {NoStop}%
\bibitem [{Avr(2022)}]{AvroSpecification}%
  \BibitemOpen
  \href@noop {} {\enquote {\bibinfo {title} {Apache avro specification},}\
  }\bibinfo {howpublished}
  {\url{https://avro.apache.org/docs/1.11.1/specification/}} (\bibinfo {year}
  {2022}),\ \bibinfo {note} {accessed: 2022-10-02}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Segal}(2005)}]{SegalJudith2005a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {J.}~\bibnamefont
  {Segal}},\ }\bibfield  {title} {\enquote {\bibinfo {title} {When software
  engineers met research scientists: A case study},}\ }\href
  {https://doi.org/10.1007/s10664-005-3865-y} {\bibfield  {journal} {\bibinfo
  {journal} {Empirical Software Engineering}\ }\textbf {\bibinfo {volume}
  {10}},\ \bibinfo {pages} {517--536} (\bibinfo {year} {2005})}\BibitemShut
  {NoStop}%
\bibitem [{Note3()}]{Note3}%
  \BibitemOpen
  \bibinfo {note} {\protect \texttt {yaqc} available on PyPI at
  https://pypi.org/project/yaqc/}\BibitemShut {NoStop}%
\bibitem [{Note4()}]{Note4}%
  \BibitemOpen
  \bibinfo {note} {\protect \texttt {yaqc-qtpy} available on PyPI at
  https://pypi.org/project/yaqc-qtpy/}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Allan}\ \emph {et~al.}(2019)\citenamefont {Allan},
  \citenamefont {Caswell}, \citenamefont {Campbell},\ and\ \citenamefont
  {Rakitin}}]{AllanDanielB2019a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {D.}~\bibnamefont
  {Allan}}, \bibinfo {author} {\bibfnamefont {T.}~\bibnamefont {Caswell}},
  \bibinfo {author} {\bibfnamefont {S.}~\bibnamefont {Campbell}},\ and\
  \bibinfo {author} {\bibfnamefont {M.}~\bibnamefont {Rakitin}},\ }\bibfield
  {title} {\enquote {\bibinfo {title} {Bluesky's ahead: A multi-facility
  collaboration for an a la carte software project for data acquisition and
  management},}\ }\href {https://doi.org/10.1080/08940886.2019.1608121}
  {\bibfield  {journal} {\bibinfo  {journal} {Synchrotron Radiation News}\
  }\textbf {\bibinfo {volume} {32}},\ \bibinfo {pages} {19--22} (\bibinfo
  {year} {2019})}\BibitemShut {NoStop}%
\bibitem [{Note5()}]{Note5}%
  \BibitemOpen
  \bibinfo {note} {\protect \texttt {yaqc-bluesky} available on PyPI at
  https://pypi.org/project/yaqc-bluesky/}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Mukamel}(2000)}]{MukamelShaul2000a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {S.}~\bibnamefont
  {Mukamel}},\ }\bibfield  {title} {\enquote {\bibinfo {title}
  {Multidimensional femtosecond correlation spectroscopies of electronic and
  vibrational excitations},}\ }\href
  {https://doi.org/10.1146/annurev.physchem.51.1.691} {\bibfield  {journal}
  {\bibinfo  {journal} {Annual Review of Physical Chemistry}\ }\textbf
  {\bibinfo {volume} {51}},\ \bibinfo {pages} {691--729} (\bibinfo {year}
  {2000})}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Wright}(2011)}]{WrightJohnCurtis2011a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {J.~C.}\ \bibnamefont
  {Wright}},\ }\bibfield  {title} {\enquote {\bibinfo {title} {Multiresonant
  coherent multidimensional spectroscopy},}\ }\href
  {https://doi.org/10.1146/annurev-physchem-032210-103551} {\bibfield
  {journal} {\bibinfo  {journal} {Annual Review of Physical Chemistry}\
  }\textbf {\bibinfo {volume} {62}},\ \bibinfo {pages} {209--230} (\bibinfo
  {year} {2011})}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Carlson}(1988)}]{CarlsonRogerJohn1988a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {R.~J.}\ \bibnamefont
  {Carlson}},\ }\emph {\bibinfo {title} {Quantitative Aspects of High
  Resolution, Fully Resonant, Four-Wave Mixing Spectroscopy For the Analysis of
  Vibronic Mode Coupling in Molecules}},\ \href@noop {} {Ph.D. thesis},\
  \bibinfo  {school} {University of Wisconsin-Madison} (\bibinfo {year}
  {1988})\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Meyer}(2004)}]{MeyerKentAlbert2004b}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {K.~A.}\ \bibnamefont
  {Meyer}},\ }\emph {\bibinfo {title} {Frequency-Scanned Ultrafast
  Spectroscopic Techniques Applied to Infrared Four-Wave Mixing
  Spectroscopy}},\ \href@noop {} {Ph.D. thesis},\ \bibinfo  {school}
  {University of Wisconsin--Madison} (\bibinfo {year} {2004})\BibitemShut
  {NoStop}%
\bibitem [{\citenamefont {Kain}(2017)}]{KainSchuyler2017a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {S.}~\bibnamefont
  {Kain}},\ }\emph {\bibinfo {title} {Transition of Frequency-Domain Coherent
  Multidimensional Spectroscopic Methods to the Femtosecond Time Regime with
  Applications to Nanoscale Semiconductors}},\ \href@noop {} {Ph.D. thesis},\
  \bibinfo  {school} {University of Wisconsin-Madison} (\bibinfo {year}
  {2017})\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Thompson}(2018)}]{ThompsonBlaiseJonathan2018a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {B.~J.}\ \bibnamefont
  {Thompson}},\ }\emph {\bibinfo {title} {Development of Frequency Domain
  Multidimensional Spectroscopy with Applications in Semiconductor
  Photophysics}},\ \href {https://doi.org/10.5281/zenodo.7627321} {Ph.D.
  thesis},\ \bibinfo  {school} {University of Wisconsin--Madison} (\bibinfo
  {year} {2018})\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Sunden}(2022)}]{SundenKyle2022}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {K.~F.}\ \bibnamefont
  {Sunden}},\ }\emph {\bibinfo {title} {yaq: Yet Another Acquisition A modular
  approach to spectroscopy software and instrumentation}},\ \href
  {https://doi.org/10.5281/zenodo.7627331} {Ph.D. thesis},\ \bibinfo  {school}
  {University of Wisconsin--Madison} (\bibinfo {year} {2022})\BibitemShut
  {NoStop}%
\bibitem [{Note6()}]{Note6}%
  \BibitemOpen
  \bibinfo {note} {\protect \texttt {yaqd-core-python} available on PyPI at
  https://pypi.org/project/yaqd-core}\BibitemShut {NoStop}%
\bibitem [{Note7()}]{Note7}%
  \BibitemOpen
  \bibinfo {note} {\protect \texttt {yaq-traits} available on PyPI at
  https://pypi.org/project/yaq-traits}\BibitemShut {NoStop}%
\bibitem [{Note8()}]{Note8}%
  \BibitemOpen
  \bibinfo {note} {\protect \texttt {yaqd-brooks-mfc-gf} source code available
  on GitHub at \protect \texttt
  {https://github.com/yaq-project/yaqd-brooks/}}\BibitemShut {NoStop}%
\bibitem [{pys()}]{pyserial}%
  \BibitemOpen
  \href@noop {} {\enquote {\bibinfo {title} {{PySerial}},}\ }\bibinfo
  {howpublished} {\url{https://pypi.org/project/pyserial}},\ \bibinfo {note}
  {accessed: 2022-10-02}\BibitemShut {NoStop}%
\bibitem [{pyu()}]{pyusb}%
  \BibitemOpen
  \href@noop {} {\enquote {\bibinfo {title} {{PyUSB}},}\ }\bibinfo
  {howpublished} {\url{https://pypi.org/project/pyusb}},\ \bibinfo {note}
  {accessed: 2022-11-06}\BibitemShut {NoStop}%
\bibitem [{pyv()}]{pyvisa}%
  \BibitemOpen
  \href@noop {} {\enquote {\bibinfo {title} {{PyVISA}},}\ }\bibinfo
  {howpublished} {\url{https://pypi.org/project/pyvisa}},\ \bibinfo {note}
  {accessed: 2022-11-06}\BibitemShut {NoStop}%
\bibitem [{pym()}]{pymodbus}%
  \BibitemOpen
  \href@noop {} {\enquote {\bibinfo {title} {{PyModbus}},}\ }\bibinfo
  {howpublished} {\url{https://pypi.org/project/pymodbus}},\ \bibinfo {note}
  {accessed: 2022-11-06}\BibitemShut {NoStop}%
\bibitem [{Note9()}]{Note9}%
  \BibitemOpen
  \bibinfo {note} {See https://yaq.fyi/daemons/ and https://yaq.fyi/hardware/
  for living lists of all \protect \texttt {yaq}{} daemons and supported
  hardware, respectively.}\BibitemShut {Stop}%
\bibitem [{\citenamefont {Salazar}\ \emph {et~al.}(2021)\citenamefont
  {Salazar}, \citenamefont {Thompson}, \citenamefont {Knapp}, \citenamefont
  {Myers},\ and\ \citenamefont {Stahl}}]{SalazarChaseA2021a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {C.~A.}\ \bibnamefont
  {Salazar}}, \bibinfo {author} {\bibfnamefont {B.~J.}\ \bibnamefont
  {Thompson}}, \bibinfo {author} {\bibfnamefont {S.~M.~M.}\ \bibnamefont
  {Knapp}}, \bibinfo {author} {\bibfnamefont {S.~R.}\ \bibnamefont {Myers}},\
  and\ \bibinfo {author} {\bibfnamefont {S.~S.}\ \bibnamefont {Stahl}},\
  }\bibfield  {title} {\enquote {\bibinfo {title} {Multichannel
  gas-uptake/evolution reactor for monitoring liquid-phase chemical
  reactions},}\ }\href {https://doi.org/10.1063/5.0043007} {\bibfield
  {journal} {\bibinfo  {journal} {Review of Scientific Instruments}\ }\textbf
  {\bibinfo {volume} {92}},\ \bibinfo {pages} {044103} (\bibinfo {year}
  {2021})}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Allman}(2012)}]{Allman_2012}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {E.}~\bibnamefont
  {Allman}},\ }\bibfield  {title} {\enquote {\bibinfo {title} {Managing
  technical debt},}\ }\href {https://doi.org/10.1145/2160718.2160733}
  {\bibfield  {journal} {\bibinfo  {journal} {Communications of the ACM}\
  }\textbf {\bibinfo {volume} {55}},\ \bibinfo {pages} {50--55} (\bibinfo
  {year} {2012})}\BibitemShut {NoStop}%
\bibitem [{Note10()}]{Note10}%
  \BibitemOpen
  \bibinfo {note} {\protect \texttt {yaqd-fakes} available on PyPI at
  https://pypi.org/project/yaqd-fakes/}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Segal}(2007)}]{SegalJudith2007a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {J.}~\bibnamefont
  {Segal}},\ }\bibfield  {title} {\enquote {\bibinfo {title} {Some problems of
  professional end user developers},}\ }in\ \href
  {https://doi.org/10.1109/vlhcc.2007.17} {\emph {\bibinfo {booktitle} {{IEEE}
  Symposium on Visual Languages and Human-Centric Computing ({VL}/{HCC}
  2007)}}}\ (\bibinfo  {publisher} {{IEEE}},\ \bibinfo {year}
  {2007})\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Cohen}\ \emph {et~al.}(2021)\citenamefont {Cohen},
  \citenamefont {Katz}, \citenamefont {Barker}, \citenamefont {Hong},
  \citenamefont {Haines},\ and\ \citenamefont {Jay}}]{CohenJeremy2021a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {J.}~\bibnamefont
  {Cohen}}, \bibinfo {author} {\bibfnamefont {D.~S.}\ \bibnamefont {Katz}},
  \bibinfo {author} {\bibfnamefont {M.}~\bibnamefont {Barker}}, \bibinfo
  {author} {\bibfnamefont {N.~C.}\ \bibnamefont {Hong}}, \bibinfo {author}
  {\bibfnamefont {R.}~\bibnamefont {Haines}},\ and\ \bibinfo {author}
  {\bibfnamefont {C.}~\bibnamefont {Jay}},\ }\bibfield  {title} {\enquote
  {\bibinfo {title} {The four pillars of research software engineering},}\
  }\href {https://doi.org/10.1109/ms.2020.2973362} {\bibfield  {journal}
  {\bibinfo  {journal} {IEEE Software}\ }\textbf {\bibinfo {volume} {38}},\
  \bibinfo {pages} {97--105} (\bibinfo {year} {2021})}\BibitemShut {NoStop}%
\bibitem [{\citenamefont {Nowogrodzki}(2019)}]{NowogrodzkiAnna2019a}%
  \BibitemOpen
  \bibfield  {author} {\bibinfo {author} {\bibfnamefont {A.}~\bibnamefont
  {Nowogrodzki}},\ }\bibfield  {title} {\enquote {\bibinfo {title} {How to
  support open-source software and stay sane},}\ }\href
  {https://doi.org/10.1038/d41586-019-02046-0} {\bibfield  {journal} {\bibinfo
  {journal} {Nature}\ }\textbf {\bibinfo {volume} {571}},\ \bibinfo {pages}
  {133--134} (\bibinfo {year} {2019})}\BibitemShut {NoStop}%
\end{thebibliography}%

\end{document}
